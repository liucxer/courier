package gengo

import (
	"bytes"
	"context"
	"fmt"
	"go/format"
	"go/parser"
	"go/scanner"
	"go/token"
	"go/types"
	"io"
	"os"
	"path"
	"sort"
	"strings"

	gengotypes "github.com/liucxer/courier/gengo/pkg/types"
	"github.com/pkg/errors"
)

func NewContext(args *GeneratorArgs) (*Context, error) {
	u, err := gengotypes.Load(args.Inputs)
	if err != nil {
		return nil, err
	}
	c := &Context{
		Args:     args,
		Universe: u,
	}
	return c, nil
}

type Context struct {
	Args     *GeneratorArgs
	Universe gengotypes.Universe

	Package gengotypes.Package
	Tags    map[string][]string
}

func (c *Context) Execute(ctx context.Context, generators ...Generator) error {
	for _, pkg := range c.Args.Inputs {
		if err := c.execPkg(ctx, pkg, generators...); err != nil {
			return err
		}
	}
	return nil
}

func (c *Context) execPkg(ctx context.Context, pkg string, generators ...Generator) error {
	p, ok := c.Universe[pkg]
	if !ok {
		return errors.Errorf("invalid pkg `%s`", pkg)
	}

	ctxWithPkg := &Context{
		Args:     c.Args,
		Universe: c.Universe,
		Package:  p,
		Tags:     map[string][]string{},
	}

	for _, f := range p.Files() {
		if f.Doc != nil && len(f.Doc.List) > 0 {
			tags, _ := gengotypes.ExtractCommentTags("+", strings.Split(f.Doc.Text(), "\n"))
			for k := range tags {
				ctxWithPkg.Tags[k] = tags[k]
			}
		}
	}

	for i := range generators {
		g := generators[i].New()
		if err := ctxWithPkg.doGenerating(ctx, g, ctxWithPkg.Tags); err != nil {
			return errors.Wrapf(err, "`%s` generate failed for %s", g.Name(), ctxWithPkg.Package.Pkg().Path())
		}
	}

	return nil
}

func isGeneratorEnabled(g Generator, tags map[string][]string) bool {
	values, ok := tags["gengo:"+g.Name()]
	return ok && strings.Join(values, "") != "false"
}

func (c *Context) doGenerating(ctx context.Context, g Generator, globalTags map[string][]string) error {
	if c.Package == nil {
		return nil
	}

	src := bytes.NewBuffer(nil)
	body := bytes.NewBuffer(nil)

	pkgTypes := c.Package.Types()

	names := make([]string, 0)

	for n := range pkgTypes {
		names = append(names, n)
	}

	sort.Strings(names)

	if _, err := fmt.Fprintf(src, `// GENERATED BY gengo:%s 
// DON'T EDIT THIS FILE
package %s
`, g.Name(), c.Package.Pkg().Name()); err != nil {
		return err
	}

	if err := g.Init(c, src); err != nil {
		return err
	}

	for _, n := range names {
		tpe := pkgTypes[n].Type()

		// skip type XXX interface{}
		if _, ok := tpe.Underlying().(*types.Interface); ok {
			continue
		}

		if named, ok := tpe.(*types.Named); ok {
			// 	skip alias other pkg type XXX = XXX2
			if named.Obj().Pkg() != c.Package.Pkg() {
				continue
			}

			doc := c.Universe.Package(named.Obj().Pkg().Path()).Doc(named.Obj().Pos())
			tags, _ := gengotypes.ExtractCommentTags("+", doc)

			mergedTags := merge(globalTags, tags)

			if isGeneratorEnabled(g, mergedTags) {
				if err := g.GenerateType(c, named, body); err != nil {
					return err
				}
			}
		}
	}

	// nothing generated
	if body.Len() == 0 {
		return nil
	}

	writeImports(g.Imports(c), src)

	if _, err := io.Copy(src, body); err != nil {
		return err
	}

	filename := path.Join(c.Package.SourceDir(), fmt.Sprintf("%s.%s.go", c.Args.OutputFileBaseName, g.Name()))
	fset := token.NewFileSet()
	data := src.Bytes()

	lines := bytes.Split(data, []byte("\n"))

	astFile, err := parser.ParseFile(fset, filename, data, parser.AllErrors)
	if err != nil {
		if sl, ok := err.(scanner.ErrorList); ok {
			for i := range sl {
				l := sl[i].Pos.Line

				fmt.Println(sl[i].Pos)

				for i := l - 3; i < l; i++ {
					if i > 0 {
						fmt.Printf("%d\t%s\n", i+1, string(lines[i]))
					}
				}

				col := sl[i].Pos.Column - 1
				if col < 0 {
					col = 0
				}
				fmt.Printf("\t%sâ†‘\n", strings.Repeat(" ", col))
				fmt.Println(sl[i].Msg)
			}
		}
		return err
	}

	formattedSrc := bytes.NewBuffer(nil)

	if err := format.Node(formattedSrc, fset, astFile); err != nil {
		return err
	}

	f, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0666)
	if err != nil {
		if os.IsNotExist(err) {
			f, err = os.Create(filename)
			if err != nil {
				return err
			}
		}
		return err
	}

	defer f.Close()

	_, err = f.Write(formattedSrc.Bytes())
	return err
}

func merge(tagsList ...map[string][]string) map[string][]string {
	mergedTags := make(map[string][]string, 0)

	for _, tags := range tagsList {
		for k, values := range tags {
			mergedTags[k] = values
		}
	}

	return mergedTags
}

func writeImports(pathToName map[string]string, w io.Writer) {
	importPaths := make([]string, 0)
	for p := range pathToName {
		importPaths = append(importPaths, p)
	}
	sort.Sort(sort.StringSlice(importPaths))

	if len(importPaths) > 0 {
		_, _ = fmt.Fprintf(w, `
import (
`)

		for _, p := range importPaths {
			_, _ = fmt.Fprintf(w, `	%s "%s"
`, pathToName[p], p)
		}

		_, _ = fmt.Fprintf(w, `)
`)
	}
}
